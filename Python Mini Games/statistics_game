
import tkinter as tk
from tkinter import messagebox, ttk
import random
import math

class StatisticsGame:
    def __init__(self, root):
        self.root = root
        self.root.title("Statistics Math Game")
        self.root.geometry("500x400")
        self.root.configure(bg="#F5F5F5")
        
        #defining a pastel color palette for the ui because it looks nicer than default colors
        self.colors = {
            "background": "#F5F5F5",
            "primary": "#B5EAD7",
            "secondary": "#FFDAC1",
            "accent": "#C7CEEA",
            "text": "#333333"
        }
        
        #initializing score and question counters to zero at the start of the game
        self.score = 0
        self.total_questions = 0
        #this will hold the current problem data like question and answer
        self.current_problem = None
        
        #calling the method to create all the widgets and ui elements
        self.create_widgets()
        #generating the first problem so the game starts immediately
        self.generate_problem()
    
    def create_widgets(self):
        #creating the main title label for the game window at the top
        title_label = tk.Label(
            self.root, 
            text="Statistics Math Challenge", 
            font=("Arial", 18, "bold"),
            fg=self.colors["text"],
            bg=self.colors["background"]
        )
        title_label.pack(pady=20)
        
        #creating a frame to hold the problem text with some padding and a raised border
        self.problem_frame = tk.Frame(
            self.root, 
            bg=self.colors["primary"],
            padx=20,
            pady=20,
            relief=tk.RAISED,
            bd=2
        )
        self.problem_frame.pack(pady=10, padx=20, fill=tk.BOTH, expand=True)
        
        #this is the label where the actual math problem will be displayed to the user
        self.problem_label = tk.Label(
            self.problem_frame,
            text="",
            font=("Arial", 14),
            wraplength=400,
            justify=tk.LEFT,
            bg=self.colors["primary"],
            fg=self.colors["text"]
        )
        self.problem_label.pack(pady=10)
        
        #creating a frame to hold the answer input elements like label and entry box
        answer_frame = tk.Frame(
            self.root,
            bg=self.colors["background"]
        )
        answer_frame.pack(pady=10)
        
        #label that says "Your Answer:" next to the input box
        tk.Label(
            answer_frame,
            text="Your Answer:",
            font=("Arial", 12),
            bg=self.colors["background"],
            fg=self.colors["text"]
        ).pack(side=tk.LEFT, padx=5)
        
        #the actual entry box where the user types their numerical answer
        self.answer_entry = tk.Entry(
            answer_frame,
            font=("Arial", 12),
            width=15
        )
        self.answer_entry.pack(side=tk.LEFT, padx=5)
        #binding the enter key to also trigger the answer checking function
        self.answer_entry.bind("<Return>", self.check_answer)
        
        #creating a frame to hold the two main buttons for checking and next problem
        button_frame = tk.Frame(
            self.root,
            bg=self.colors["background"]
        )
        button_frame.pack(pady=10)
        
        #button that when clicked will check if the user's answer is correct or not
        check_button = tk.Button(
            button_frame,
            text="Check Answer",
            font=("Arial", 12),
            bg=self.colors["accent"],
            fg="white",
            command=self.check_answer,
            padx=10,
            pady=5
        )
        check_button.pack(side=tk.LEFT, padx=5)
        
        #button that generates a new problem when the user wants to skip or move on
        next_button = tk.Button(
            button_frame,
            text="Next Problem",
            font=("Arial", 12),
            bg=self.colors["secondary"],
            fg=self.colors["text"],
            command=self.generate_problem,
            padx=10,
            pady=5
        )
        next_button.pack(side=tk.LEFT, padx=5)
        
        #label that shows the current score out of total questions attempted
        self.score_label = tk.Label(
            self.root,
            text="Score: 0/0",
            font=("Arial", 12),
            bg=self.colors["background"],
            fg=self.colors["text"]
        )
        self.score_label.pack(pady=10)
    
    def generate_problem(self):
        #clearing the answer entry box from the previous problem
        self.answer_entry.delete(0, tk.END)
        #randomly selecting which type of statistics problem to generate
        problem_type = random.choice([
            "mean", 
            "median", 
            "mode", 
            "range",
            "probability",
            "standard_deviation"
        ])
        
        #generating a mean average problem with random numbers and calculating the average
        if problem_type == "mean":
            #creating a list of random numbers between 1 and 100 of random length between 5 and 10
            data = [random.randint(1, 100) for _ in range(random.randint(5, 10))]
            #calculating the mean by summing all numbers and dividing by count
            correct_answer = sum(data) / len(data)
            #storing the question and answer in the current problem dictionary
            self.current_problem = {
                "question": f"Calculate the mean of the following numbers: {', '.join(map(str, data))}",
                "answer": round(correct_answer, 2)
            }
            
        #generating a median problem where we find the middle value in sorted data
        elif problem_type == "median":
            #creating sorted random data to find the median more easily
            data = sorted([random.randint(1, 100) for _ in range(random.randint(5, 10))])
            n = len(data)
            #if odd number of elements, median is the middle one
            if n % 2 == 1:
                correct_answer = data[n//2]
            #if even number, median is average of two middle values
            else:
                correct_answer = (data[n//2 - 1] + data[n//2]) / 2
            self.current_problem = {
                "question": f"Find the median of the following numbers: {', '.join(map(str, data))}",
                "answer": correct_answer
            }
            
        #generating a mode problem to find the most frequent number in the data
        elif problem_type == "mode":
            #creating initial random data but then ensuring there's at least one mode by adding duplicates
            data = [random.randint(1, 10) for _ in range(10)]
            #adding duplicates of the first two elements to guarantee a mode exists
            data.extend([data[0], data[1]])
            random.shuffle(data)
            
            #counting frequency of each number in the dataset
            frequency = {}
            for num in data:
                frequency[num] = frequency.get(num, 0) + 1
            
            #finding the maximum frequency value
            max_freq = max(frequency.values())
            #finding all numbers that have that maximum frequency (could be multiple modes)
            modes = [num for num, freq in frequency.items() if freq == max_freq]
            
            #storing the problem, handling cases where there might be multiple modes
            self.current_problem = {
                "question": f"Find the mode of the following numbers: {', '.join(map(str, data))}",
                "answer": modes[0] if len(modes) == 1 else modes
            }
            
        #generating a range problem which is the difference between max and min values
        elif problem_type == "range":
            data = [random.randint(1, 100) for _ in range(random.randint(5, 10))]
            #range is simply max value minus min value in the dataset
            correct_answer = max(data) - min(data)
            self.current_problem = {
                "question": f"Calculate the range of the following numbers: {', '.join(map(str, data))}",
                "answer": correct_answer
            }
            
        #generating a simple probability problem with favorable and total outcomes
        elif problem_type == "probability":
            total_outcomes = random.randint(10, 20)
            favorable_outcomes = random.randint(1, total_outcomes)
            #probability is favorable outcomes divided by total possible outcomes
            correct_answer = favorable_outcomes / total_outcomes
            self.current_problem = {
                "question": f"If there are {favorable_outcomes} favorable outcomes out of {total_outcomes} total outcomes, what is the probability?",
                "answer": round(correct_answer, 2)
            }
            
        #generating a standard deviation problem which requires more complex calculation
        elif problem_type == "standard_deviation":
            data = [random.randint(1, 100) for _ in range(random.randint(5, 10))]
            #first calculate the mean average of the data
            mean = sum(data) / len(data)
            #then calculate variance which is average of squared differences from mean
            variance = sum((x - mean) ** 2 for x in data) / len(data)
            #standard deviation is the square root of the variance
            correct_answer = math.sqrt(variance)
            self.current_problem = {
                "question": f"Calculate the standard deviation of the following numbers: {', '.join(map(str, data))}",
                "answer": round(correct_answer, 2)
            }
        
        #updating the problem label with the new generated question text
        self.problem_label.config(text=self.current_problem["question"])
    
    def check_answer(self, event=None):
        #safety check to make sure there's actually a current problem to check against
        if self.current_problem is None:
            return
            
        #getting the user's answer from the input box as a string
        user_answer = self.answer_entry.get()
        #if the user didn't enter anything, show a warning message
        if not user_answer:
            messagebox.showwarning("Input Error", "Please enter an answer.")
            return
            
        try:
            #convert the user's answer to a float number for comparison
            user_answer = float(user_answer)
            correct_answer = self.current_problem["answer"]
            
            #special handling for mode problems which might have multiple correct answers
            if isinstance(correct_answer, list):
                #check if user's answer is one of the correct mode values
                is_correct = user_answer in correct_answer
                #prepare a string representation of correct answers for the message
                correct_answer_str = " or ".join(map(str, correct_answer))
            else:
                #for other problems, check if answer is close enough (floating point tolerance)
                is_correct = abs(user_answer - correct_answer) < 0.01
                #round the correct answer for display purposes
                correct_answer_str = str(round(correct_answer, 2))
            
            #increment the total questions counter regardless of right or wrong
            self.total_questions += 1
            if is_correct:
                #if answer is correct, increment score and show success message
                self.score += 1
                messagebox.showinfo("Result", "Correct! ðŸŽ‰")
            else:
                #if answer is wrong, show error message with the correct answer
                messagebox.showerror("Result", f"Incorrect. The correct answer is {correct_answer_str}.")
                
            #update the score display label with the new score values
            self.score_label.config(text=f"Score: {self.score}/{self.total_questions}")
            
        #if the user entered something that can't be converted to a number, show error
        except ValueError:
            messagebox.showerror("Input Error", "Please enter a valid number.")
            return

if __name__ == "__main__":
    #creating the main tkinter root window
    root = tk.Tk()
    #creating an instance of our statistics game class
    app = StatisticsGame(root)
    #starting the main event loop that keeps the application running
    root.mainloop()